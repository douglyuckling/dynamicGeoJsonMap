<!DOCTYPE html>
<meta charset="utf-8">
<style>
body { margin: 0; }

.background {
    fill: hsl(0, 0%, 100%);
    stroke: none;
}

.shapes, .bounds-outlines {
    pointer-events: none;
}

.ocean {
    fill: hsl(180, 25%, 85%);
}

.subunit {
    fill: hsl(0, 0%, 75%);
    stroke: hsl(0, 0%, 100%);
}

.viewport {
    fill: hsl(0, 0%, 75%);
    stroke: none;
    mix-blend-mode: multiply;
    pointer-events: none;
}

.viewport-bounds-outline {
    fill: none;
    stroke: hsl(0, 0%, 0%);
}

.subunit-bounds-outline {
    fill: none;
    stroke-dasharray: 2, 2;
    stroke: hsl(0, 0%, 50%);
}

.subunit-bounds-outline.culled {
    fill: none;
    stroke: hsl(0, 100%, 50%);
}

text {
    font-family: "Helvetica Neue", Helvetica, Arial, sans-serif;
    font-size: 64px;
    pointer-events: none;
}

</style>
<body>
<script src="http://d3js.org/d3.v3.min.js"></script>
<script src="http://d3js.org/topojson.v1.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/underscore.js/1.8.3/underscore-min.js"></script>
<script>

var width = 900;
var height = 1088;
var baseScale = 5625;

var formatArea = d3.format(".2r");
var formatPercent = d3.format(".2%");
var formatFps = d3.format(".2r");

var zoom = d3.behavior.zoom()
    .scale(baseScale)
    .scaleExtent([175, 300000])
    .translate([width / 2, height / 2]);

var svg = d3.select("body").append("svg")
    .attr("width", width)
    .attr("height", height);

var background = svg.append('rect')
    .attr('class', 'background')
    .attr('width', width)
    .attr('height', height)
    .call(zoom);

var shapes = svg.append('g')
    .attr('class', 'shapes');

var ocean = shapes.append('path')
    .attr('class', 'ocean')
    .datum({type: 'Sphere'});

var viewportPath = svg.append('path')
    .attr('class', 'viewport');

var boundsOutlines = svg.append('g')
    .attr('class', 'bounds-outlines');

var viewportBoundsOutline = boundsOutlines.append('path')
    .attr('class', 'viewport-bounds-outline');

var text = svg.append("text")
    .attr("x", width / 2)
    .attr("y", height / 2)
    .attr("dy", ".35em")
    .attr("text-anchor", "middle");
var tspan1 = text.append('tspan')
    .attr('x', text.attr('x'))
    .attr('y', text.attr('y'))
    .attr('dy', '.35em');
var tspan2 = text.append('tspan')
    .attr('x', text.attr('x'))
    .attr('y', text.attr('y'))
    .attr('dy', '1.45em');
var tspan3 = text.append('tspan')
    .attr('x', text.attr('x'))
    .attr('y', text.attr('y'))
    .attr('dy', '2.55em');

var clip = d3.geo.clipExtent()
    .extent([[0, 0], [width, height]]);

d3.json("uk.topo.json", function(error, uk) {
    if (error) return console.error(error);

    var subunits = topojson.feature(uk, uk.objects.subunits);
    subunits.features.forEach(function(subunit) {
        subunit.properties['bounds'] = d3.geo.bounds(subunit);
    });

    var areaInSteradians = d3.geo.area(subunits);

    var albersProjection = d3.geo.albers()
        .center([0, 55.4])
        .rotate([4.4, 0])
        .parallels([50, 60])
        .scale(zoom.scale())
        .translate(zoom.translate());

    var baseMetrics = renderFeatures(0);
    var areaInPixels = d3.geo.path().projection(albersProjection).area(subunits);
    var baseSteradiansPerSquarePixels = areaInSteradians / areaInPixels;

    redraw(baseSteradiansPerSquarePixels);

    var x = d3.scale.sqrt()
        .domain([0, baseMetrics.maxArea])
        .range([0, width]);

    zoom.on('zoom', function() {
        var magnification = d3.event.scale / baseScale;
        var steradiansPerSquarePixels = baseSteradiansPerSquarePixels / Math.pow(magnification, 2);

        albersProjection
            .scale(d3.event.scale)
            .translate(d3.event.translate);
        redraw(steradiansPerSquarePixels);
    });

    function redraw(steradiansPerSquarePixels) {
        var metrics = renderFeatures(steradiansPerSquarePixels);

        tspan1.text(formatArea(steradiansPerSquarePixels) + " sr/pxÂ²");
        tspan2.text(formatPercent(metrics.pointsProjected / baseMetrics.totalPoints) + " of pts");
        tspan3.text(formatFps(1000 / metrics.renderTime) + " fps");
    }

    function renderFeatures(minAreaInSteradians) {
        var padding = 150;
        var viewportPolygonInGeoCoordinates = {
            type: 'Polygon',
            coordinates: [
                createLinearRingFromBounds([
                    [0+padding, height-padding],
                    [width-padding, 0+padding]
                ]).map(albersProjection.invert)
            ]
        };
        var viewportBounds = d3.geo.bounds(viewportPolygonInGeoCoordinates);

        var beginTime = performance.now();
        var metrics = {
            totalPoints: 0,
            pointsProjected: 0,
            maxArea: 0
        };

        var filterPoints = d3.geo.transform({
          point: function(x, y, z) {
            metrics.totalPoints++;
            if (!(z < minAreaInSteradians)) {
                this.stream.point(x, y);
                metrics.pointsProjected++;
            }
            if (z > metrics.maxArea) {
                metrics.maxArea = z;
            }
          }
        });

        var path = d3.geo.path()
            .projection({
                stream: function(s) {
                    return filterPoints.stream(albersProjection.stream(clip.stream(s)));
                }
            });

        ocean.attr('d', path);

        var subunitShapes = shapes.selectAll(".subunit")
            .data(subunits.features.filter(function(d) {
                return boundsOverlap(viewportBounds, d.properties.bounds);
            }), function(d) { return d.id; });

        subunitShapes.enter().append("path")
            .attr("class", function(d) { return "subunit " + d.id; });

        subunitShapes.exit().remove();

        subunitShapes
            .attr("d", path);

        var boundsPath = d3.geo.path().projection(albersProjection);

        viewportPath
            .datum(viewportPolygonInGeoCoordinates)
            .attr('d', function(d) {
                return 'M0 0 v' + height + ' h' + width + ' v' + (-height) + 'z'
                + boundsPath(d);
            });

        var subunitBoundsOutlines = boundsOutlines.selectAll(".subunit-bounds-outline")
            .data(subunits.features, function(d) { return d.id; });

        subunitBoundsOutlines.enter().append("path")
            .attr("class", function(d) { return "subunit-bounds-outline " + d.id; });

        subunitBoundsOutlines
            .attr('d', function(d) {
                return boundsPath({
                    type: 'Polygon',
                    coordinates: [createLinearRingFromBounds(d.properties.bounds)]
                });
            })
            .classed('culled', function(d) {
                return !boundsOverlap(viewportBounds, d.properties.bounds);
            });

        viewportBoundsOutline
            .datum(viewportBounds)
            .attr('d', function(d) {
                return boundsPath({
                    type: 'Polygon',
                    coordinates: [createLinearRingFromBounds(d)]
                });
            });

        metrics.renderTime = performance.now() - beginTime;

        return metrics;
    }

    function boundsOverlap(a, b) {
        var dimensions = Object.keys(a[0]);
        return _(dimensions).every(function(i) {
            return a[0][i] < b[1][i] && b[0][i] < a[1][i];
        });
    }

    function createLinearRingFromBounds(bounds) {
        var x0 = bounds[0][0];
        var x1 = bounds[1][0];
        var y0 = bounds[0][1];
        var y1 = bounds[1][1];

        return interpolate([
            [x0, y0],
            [x0, y1],
            [x1, y1],
            [x1, y0],
            [x0, y0],
        ], 3);
    }

    function interpolate(points, iterations) {
        while (iterations > 0) {
            var interpolated = [];
            for (var i=0, n=points.length-1; i < n; i++) {
                interpolated.push(points[i]);
                interpolated.push(midpoint(points[i], points[i+1]));
            }
            interpolated.push(points[points.length-1]);

            points = interpolated;
            iterations--;
        }

        return points;
    }

    function midpoint(p0, p1) {
        var dimensions = Object.keys(p0);
        return dimensions.map(function(i) {
            return (p0[i] + p1[i]) / 2;
        });
    }

});

</script>
